---
layout: default
title: 《SICP》学习小结（第三章之一）
excerpt: 学到这里，我视乎看到了scheme语言运行的内部过程。
tags: [Coding]
---
{{ page.title }}
================

目前《SICP》第三章的学习正在如火如荼的进行中，有点小感悟，总结如下：

第三章第一小节，主要介绍了使用对象化的方法来编程。之前两章中，我们将符号看做是一个名字，指代值或者过程的一个名字。通过第一章介绍的代换模型，总可以把一个过程代换成一系列基本的运算符号。这种也就是所谓的函数式编程，给定固定的输入，获得固定的输出，不会有改变。第三章中引进了赋值操作set！，这个运算符可以改变某个符号的值。这样代换模型就没法很好的解释程序行为了。这里我们不能把符号只看做一个名字，而必须看做是一个对象，拥有自己的值并存放在某处。通过赋值运算符，可以改变符号的值。在不同的情况下，求值同样的过程，可能有不同的解。其实说白了，就是scheme在这里引进了局部变量。

第三章第二小节，引进了为了理解对象化的环境模型。解释了每一个过程本身有符号约束，所在的上层环境中也有符号约束。学到这里，scheme解开了自己内部神秘的面纱。在一个过程所处的上层环境中变量值的改变，会影响这个过程的行为。不知道为什么在这里,《SICP》进行了详尽的环境模型演示，其实这种环境模型就相当于C语言中的变量作用域而已。如果学习了C语言，再来看这一节的解释，就很明了了。整个scheme解释器环境就相当于一个正在运行的main函数，每个变量名都有一个值。如果这个变量是个全局变量，修改变量的值，必然会影响使用它的子函数运算结果。

第三章第三小节，又介绍了一种修改变结构的操作符set-car!与set-cdr!。在我看来，这就是对指针的操作。将scheme中的列表看做是C语言中实现的链表结构，修改scheme的列表中的值，就是对链表指针的操作。后面介绍了设计队列操作的方法，与C语言的队列实现如出一辙。比C语言好的地方是，scheme把指针操作封装起来了，大大保证了安全性。并且自带了垃圾回收，不用手工去释放没用的对象所占的内存。列表也是实现好了，不用自己去用结构体实现。看到这里，我豁然开朗，明白了scheme列表实现的具体细节。我用scheme写了个汉诺塔游戏，其实就是实现好堆栈，写出堆栈操作的过程，与C语言写是没什么两样的。

学到这里，我视乎看到了scheme语言运行的内部过程。与C语言比较起来，scheme的语法更加灵活，数据结构也更加灵活，但说到底，内部细节也是可以想象成一个巨大运行的C程序。这种联系和想象，可以帮助我更好的学习《SICP》。

{{ page.date | date: "%Y-%m-%d" }}
